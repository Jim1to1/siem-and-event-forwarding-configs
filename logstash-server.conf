input {

				lumberjack {
							port => 8516
							type => "bro_logs"
							ssl_certificate => "/etc/pki/tls/certs/logstash-forwarder_bro.crt"
							ssl_key => "/etc/pki/tls/private/logstash-forwarder_bro.key"
						}

				lumberjack {
							port => 8517
							type => "suricata_log"
							ssl_certificate => "/etc/pki/tls/certs/logstash-forwarder.crt"
							ssl_key => "/etc/pki/tls/private/logstash-forwarder.key"
							#codec => json
						}

				udp {
							port => 8518
							type => "palo_alto_traffic_log"
					}

				tcp {
						port => 8520
						type => "fireeye_log"
						#fenotify rsyslog trap-sink $LogstashServer prefer message format json_legacy-normal 
						#fenotify rsyslog trap-sink $LogstashServer port 8520
						#fenotify rsyslog trap-sink $LogstashServer protocol tcp
						#fenotify rsyslog trap-sink $LogstashServer address $LogstashServer
					}

				syslog {
						port => 514
						type => "syslog_log"
					}

				tcp {
						port => 8531
						type => "windows_event_log"
						#-i -accepteula -h md5,sha1,sha256,imphash #Sysmon install on client with no networking and all hashes
						#-i -accepteula -h md5,sha1,sha256,imphash -n #Sysmon install on client with networking and all hashes
					}

				#file {
				#	   path => "/nsm/sensor_data/suri-eth1/eve.json"
				#	   type => "suricata_log"
				#	   start_position => "beginning"
				#	   sincedb_path => "/var/lib/logstash/"
				#	   codec => json
				#}

				#file {
				#	path => "/nsm/bro/logs/current/dns.log"
				#	type => "bro_dns_log"
				#	start_position => "beginning"
				#	sincedb_path => "/var/lib/logstash/"
				#}
				   #
				#file {
				#	 path => "/nsm/bro/logs/current/http_eth1.log"
				#	 type => "bro_http_log"
				#	start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				#}
				   #
				#file {
				#	 path => "/nsm/bro/logs/current/conn.log"
				#	 type => "bro_conn_log"
				#	start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				#}
				   #
				#file {
				#	 path => "/nsm/bro/logs/current/files.log"
				#	 type => "bro_files_log"
				#	 start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				#}
				   #
				#file {
				#	 path => "/nsm/bro/logs/current/ssl.log"
				#	 type => "bro_ssl_log"
				#	 start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				#}
				   #
				#file {
				#	 path => "/nsm/bro/logs/current/dhcp.log"
				#	 type => "bro_dhcp_log"
				#	 start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				# }

				#file {
				#	 path => "/nsm/bro/logs/current/x509.log"
				#	 type => "bro_x509_log"
				#	 start_position => "beginning"
				#	 sincedb_path => "/var/lib/logstash/"
				# }

}

filter {

        if [message] =~ /^#/ {
                drop { }
        }
        else {


			#Palo Alto Traffic Logs
			if [type] == "palo_alto_traffic_log" and [message] =~ /TRAFFIC/ {
				csv {
						columns => [ "Domain", "ReceiveTime", "Serial", "Type", "ThreatContent Type", "Config Version", "Generate Time", "src_ip", "dst_ip", "NAT src_ip", "NAT dst_ip", "Rule", "Source User","Destination User","Application","Virtual System","Source Zone","Destination Zone","Inbound Interface","Outbound Interface","Log Action","Time Logged","Session ID","Repeat Count","src_port","dst_port","NAT src_port","NAT dst_port","Flags","protocol","Action","Bytes","Bytes Sent","Bytes Received","Packets","Start Time","Elapsed Time (sec)","Category","Padding","seqno","actionflags","Source Country","Destination Country","cpadding","pkts_sent","pkts_received", "session_end_reason", "COLUMN48", "COLUMN49", "COLUMN50", "COLUMN51", "VSYS_Name", "device_name", "Policy_Direction" ]
						#remove_field => [ "actionflags", "Config Version", "cpadding", "Domain", "Flags", "Elapsed Time (sec)","Generate Time", "Inbound Interface", "NAT Source IP", "NAT Destination IP","NAT src_port","NAT dst_port", "Padding", "seqno", "Serial", "Session ID", "src_port", "Time Logged", "Virtual System" ]
						remove_field => [ "NAT src_ip", "NAT dst_ip","NAT src_port","NAT dst_port", "Domain", "Flags", "Padding", "cpadding", "seqno", "actionflags", "Config Version", "Virtual System"", "COLUMN48", "COLUMN49", "COLUMN50", "COLUMN51" ]
						}

				date {
						match => [ "Start time", "UNIX" ]
						}


				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
			  		}
				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
			  		}
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }


                mutate {
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
                        convert => [ "Bytes", "integer" ]
                        convert => [ "Bytes Sent", "integer" ]
                        convert => [ "Bytes Received", "integer" ]
                        convert => [ "Packets", "integer" ]
                        convert => [ "pkts_sent", "integer" ]
                        convert => [ "pkts_received", "integer" ]
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
                        }


        }

			####Bro DNS
			if [type] == "bro_dns_log" {

                 csv {
                 		separator => "	"
                 		columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "protocol", "trans_id", "query", "qclass", "qclass_name", "qtype", "qtype_name", "rcode", "rcode_name", "AA", "TC", "RD", "RA", "Z", "answers", "TTLs", "rejected" ]
                 		}

                date {
                        match => [ "ts", "UNIX" ]
                        }

				#geoip {
				#	source => "src_ip"
				#	target => "src_ip_geoip"
				#	database =>"/usr/share/GeoIP/GeoLiteCity.dat"
				#	add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
				#	add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
			  	#	}
				#geoip {
				#	source => "src_ip"
				#	target => "src_ip_geoip"
				#	database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 	#	 }
				#geoip {
				#	source => "dst_ip"
				#	target => "dst_ip_geoip"
				#	database =>"/usr/share/GeoIP/GeoLiteCity.dat"
				#	add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
				#	add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
			 	#	 }
				#geoip {
				#	source => "dst_ip"
				#	target => "dst_ip_geoip"
				#	database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 	#	 }

                mutate {
                        #src_port
                        #dst_port
                        #trans_id
                        #qclass
                        #qtype
                        #rcode
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
                        convert => [ "trans_id", "integer" ]
                        convert => [ "qclass", "integer" ]
                        convert => [ "qtype", "integer" ]
                        convert => [ "rcode", "integer" ]
						#convert => [ "[src_ip_geoip][coordinates]", "float" ]
						#convert => [ "[dst_ip_geoip][coordinates]", "float" ]
						lowercase => [ "query" ]
                        }

                #Get rid of bad lookups
				if [query] == '*\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' {
							drop { }
					}

        }


			####Bro HTTP
			if [type] == "bro_http_log" {

                 csv {
                 		separator => "	"
                 		columns => [ "ts",  "uid",  "src_ip",  "src_port",  "dst_ip",  "dst_port",  "trans_depth",  "method",  "http_host",  "uri",  "referrer",  "user_agent",  "request_body_len",  "response_body_len",  "status_code",  "status_msg",  "info_code",  "info_msg",  "filename",  "http_tags",  "username",  "password",  "proxied",  "flash_version",  "accept_language",  "x_requested_with",  "content_range",  "range",  "orig_fuids",  "orig_mime_types",  "resp_fuids",  "resp_mime_types" ]
                 		}


                date {
                        match => [ "ts", "UNIX" ]
                        }

				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
			  		}
				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }

                mutate {
                        #src_port
                        #dst_port
                        #trans_depth
                        #request_body_len
                        #response_body_len
                        #status_code
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
                        convert => [ "trans_depth", "integer" ]
                        convert => [ "request_body_len", "integer" ]
                        convert => [ "response_body_len", "integer" ]
                        convert => [ "status_code", "integer" ]
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
                        }

                }

			####Bro Conn
			if [type] == "bro_conn_log" {

                 csv {
                 		separator => "	"
                 		columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "protocol", "Application", "duration", "orig_bytes", "resp_bytes", "conn_state", "local_orig", "missed_bytes", "history", "orig_pkts", "orig_ip_bytes", "resp_pkts", "resp_ip_bytes", "tunnel_parents", "orig_cc", "resp_cc", "sensorname" ]
                 		}

                date {
                        match => [ "ts", "UNIX" ]
                        }

				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
			  		}
				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }

                mutate {
                        #src_port
                        #dst_port
                        #orig_bytes
                        #resp_bytes
                        #missed_bytes
                        #orig_pkts
                        #orig_ip_bytes
                        #resp_pkts
                        #resp_ip_bytes
                        #duration
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
                        convert => [ "orig_bytes", "integer" ]
                        convert => [ "resp_bytes", "integer" ]
                        convert => [ "missed_bytes", "integer" ]
                        convert => [ "orig_pkts", "integer" ]
                        convert => [ "orig_ip_bytes", "integer" ]
                        convert => [ "resp_pkts", "integer" ]
                        convert => [ "resp_ip_bytes", "integer" ]
                        convert => [ "duration", "float" ]
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
                        }

                #The following makes use of the translate filter (logstash contrib) to convert conn_state into human text. Saves having to look up values for packet introspection
                translate {
                  field => "conn_state"
                  destination => "conn_state_full"
                  dictionary => [
                        "S0", "Connection attempt seen, no reply",
                        "S1", "Connection established, not terminated",
                        "S2", "Connection established and close attempt by originator seen (but no reply from responder)",
                        "S3", "Connection established and close attempt by responder seen (but no reply from originator)",
                        "SF", "Normal SYN/FIN completion",
                        "REJ", "Connection attempt rejected",
                        "RSTO", "Connection established, originator aborted (sent a RST)",
                        "RSTR", "Established, responder aborted",
                        "RSTOS0", "Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder",
                        "RSTRH", "Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator",
                        "SH", "Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was 'half' open)",
                        "SHR", "Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator",
                        "OTH", "No SYN seen, just midstream traffic (a 'partial connection' that was not later closed)"
                  ]
    }
        }
			####Bro Files
			if [type] == "bro_files_log" {

                 csv {
                 		separator => "	"
                 		columns => [ "ts", "fuid", "src_ip", "dst_ip", "conn_uids", "Application", "depth", "analyzers", "resp_mime_types", "filename", "duration", "local_orig", "is_orig", "seen_bytes", "total_bytes", "missing_bytes", "overflow_bytes", "timedout", "parent_fuid", "md5", "sha1", "sha256", "extracted" ]
                 		}
                 #grok {
                 #		match => [ "message", "(?<ts>(.*?))\t(?<fuid>(.*?))\t(?<src_ip>(.*?))\t(?<dst_ip>(.*?))\t(?<conn_uids>(.*?))\t(?<Application>(.*?))\t(?<depth>(.*?))\t(?<analyzers>(.*?))\t(?<resp_mime_types>(.*?))\t(?<filename>(.*?))\t(?<duration>(.*?))\t(?<local_orig>(.*?))\t(?<is_orig>(.*?))\t(?<seen_bytes>(.*?))\t(?<total_bytes>(.*?))\t(?<missing_bytes>(.*?))\t(?<overflow_bytes>(.*?))\t(?<timedout>(.*?))\t(?<parent_fuid>(.*?))\t(?<md5>(.*?))\t(?<sha1>(.*?))\t(?<sha256>(.*?))\t(?<extracted>(.*))" ]

                 #}


                date {
                        match => [ "ts", "UNIX" ]
                        }

				geoip {
					source => "src_ip"
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
					add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
			  		}
				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoLiteCity.dat"
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
					add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
			 		 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
			 		 }


                mutate {
                		#src_port
                		#dst_port
                        #seen_bytes
                        #total_bytes
                        #missing_bytes
                        #overflow_bytes
                        #duration
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
                        convert => [ "seen_bytes", "integer" ]
                        convert => [ "total_bytes", "integer" ]
                        convert => [ "missing_bytes", "integer" ]
                        convert => [ "overflow_bytes", "integer" ]
                        convert => [ "duration", "float" ]
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
                	}
        }
			####Bro SSL
			if [type] == "bro_ssl_log" {

                 csv {
                 		separator => "	"
                 		columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "version", "cipher", "curve", "server_name", "resumed", "last_alert", "next_protocol", "established", "cert_chain_fuids", "client_cert_chain_fuids", "subject", "issuer", "client_subject", "client_issuer", "validation_status" ]
                 		}

                date {
                        match => [ "ts", "UNIX" ]
                        }

				geoip {
						source => "src_ip"
						target => "src_ip_geoip"
						database =>"/usr/share/GeoIP/GeoLiteCity.dat"
						add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
						add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
						}
				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
					 }
				geoip {
						source => "dst_ip"
						target => "dst_ip_geoip"
						database =>"/usr/share/GeoIP/GeoLiteCity.dat"
						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
						 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
					 }

                mutate {
                        #src_port
                        #dst_port
                        convert => [ "src_port", "integer" ]
                        convert => [ "dst_port", "integer" ]
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
                        }
        }

			####Bro DHCP
			if [type] == "bro_dhcp_log" {

							csv {
									separator => "	"
									columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "mac", "assigned_ip", "lease_time", "trans_id" ]
								}
							date {
									match => [ "ts", "UNIX" ]
									}

							mutate {
									#src_port
									#dst_port
									#depth
									#seen_bytes
									#total_bytes
									#missing_bytes
									#overflow_bytes
									#trans_id
									#lease_time
									convert => [ "src_port", "integer" ]
									convert => [ "dst_port", "integer" ]
									convert => [ "depth", "integer" ]
									convert => [ "seen_bytes", "integer" ]
									convert => [ "total_bytes", "integer" ]
									convert => [ "missing_bytes", "integer" ]
									convert => [ "overflow_bytes", "integer" ]
									convert => [ "trans_id", "integer" ]
									convert => [ "lease_time", "float" ]
								}
       					 }

			####Bro X509
			if [type] == "bro_x509_log" {

							csv {
									separator => "	"
									columns => [ "ts", "id", "certificate.version", "certificate.serial", "certificate.subject", "certificate.issuer", "certificate.not_valid_before", "certificate.not_valid_after", "certificate.key_alg", "certificate.sig_alg", "certificate.key_type", "certificate.key_length", "certificate.exponent", "certificate.curve", "san.dns", "san.uri", "san.email", "san.ip", "basic_constraints.ca", "basic_constraints.path_len" ]
								}
							date {
									match => [ "ts", "UNIX" ]
									target => "@timestamp"
								}
							date {
									match => [ "certificate.not_valid_before", "UNIX" ]
									target => "certificate.not_valid_before"
								}
							date {
									match => [ "certificate.not_valid_after", "UNIX" ]
									target => "certificate.not_valid_after"
								}

							mutate {
									#certificate.version
									#certificate.key_length
									#basic_constraints.path_len
									convert => [ "certificate.version", "integer" ]
									convert => [ "certificate.key_length", "integer" ]
									convert => [ "basic_constraints.path_len", "integer" ]
								}
       					 }

       		####Bro Notice
       		if [type] == "bro_notice_log" {

							csv {
									separator => "	"
									columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "fuid", "resp_mime_types", "file_desc", "protocol", "note", "msg", "sub", "src", "dst", "p", "n", "peer_descr", "actions", "suppress_for", "dropped", "remote_location.country_code", "remote_location.region", "remote_location.city", "remote_location.latitude", "remote_location.longitude" ]
									remove_field => [ "remote_location.country_code", "remote_location.region", "remote_location.city", "remote_location.latitude", "remote_location.longitude" ]
								}

							date {
									match => [ "ts", "UNIX" ]
									}
                            #
							#geoip {
							#		source => "src_ip"
							#		target => "src_ip_geoip"
							#		database =>"/usr/share/GeoIP/GeoLiteCity.dat"
							#		add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
							#		add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
							#		}
							#geoip {
							#	source => "src_ip"
							#	target => "src_ip_geoip"
							#	database =>"/usr/share/GeoIP/GeoIPASNum.dat"
							#	 }
							#geoip {
							#		source => "dst_ip"
							#		target => "dst_ip_geoip"
							#		database =>"/usr/share/GeoIP/GeoLiteCity.dat"
							#		add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
							#		add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
							#		 }
							#geoip {
							#	source => "dst_ip"
							#	target => "dst_ip_geoip"
							#	database =>"/usr/share/GeoIP/GeoIPASNum.dat"
							#	 }

							mutate {
									#src_port
									#dst_port
									convert => [ "src_port", "integer" ]
									convert => [ "dst_port", "integer" ]
									#convert => [ "[src_ip_geoip][coordinates]", "float" ]
									#convert => [ "[dst_ip_geoip][coordinates]", "float" ]
									}
						}
						
			####Bro SSH
			if [type] == "bro_ssh_log" {

	                 csv {
	                        separator => "	"
	                        columns => [ "ts", "uid", "src_ip", "src_port", "dst_ip", "dst_port", "version", "auth_success", "direction", "client", "server", "cipher_alg", "mac_alg", "compression_alg", "kex_alg", "host_key_alg", "host_key" ]
	                        }

	                date {
	                        match => [ "ts", "UNIX" ]
	                        }

					geoip {
							source => "src_ip"
							target => "src_ip_geoip"
							database =>"/usr/share/GeoIP/GeoLiteCity.dat"
							add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
							add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
							}
					geoip {
						source => "src_ip"
						target => "src_ip_geoip"
						database =>"/usr/share/GeoIP/GeoIPASNum.dat"
						 }
					geoip {
							source => "dst_ip"
							target => "dst_ip_geoip"
							database =>"/usr/share/GeoIP/GeoLiteCity.dat"
							add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
							add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
							 }
					geoip {
						source => "dst_ip"
						target => "dst_ip_geoip"
						database =>"/usr/share/GeoIP/GeoIPASNum.dat"
						 }

	                mutate {
	                        #src_port
	                        #dst_port
	                        convert => [ "src_port", "integer" ]
	                        convert => [ "dst_port", "integer" ]
							convert => [ "[src_ip_geoip][coordinates]", "float" ]
							convert => [ "[dst_ip_geoip][coordinates]", "float" ]
	                        }
                }

			####Windows Log
			if [type] == "windows_event_log" {
					json{
							source => "message"
					}
						mutate {
									lowercase => [ "Hostname" ]
									remove_field => [ "SourceModuleName", "SourceModuleType" ]
								}								
					if [Channel] == "Microsoft-Windows-Sysmon/Operational" {
					
						mutate {
									remove_field => [ "EventType" ]
									rename => [ "Message", "description" ]
								}
						translate {
									  field => "EventID"
									  destination => "event_description"
									  dictionary => [
														"1", "process creation",
														"2", "a process change a file creation time",
														"3", "network connection",
														"4", "sysmon service state changed",
														"5", "process terminated",
														"6", "driver loaded",
														"7", "image loaded",
														"8", "create remote thread detected",
														"255", "error"
									  				]
								}
						if [EventID] == 1 {
										mutate {
											split => ["Hashes", ","]
											convert => [ "ParentProcessId", "integer" ]
											convert => [ "ProcessID", "integer" ]
											convert => [ "RecordNumber", "integer" ]
											convert => [ "SequenceNumber", "integer" ]
											convert => [ "SeverityValue", "integer" ]
											convert => [ "TerminalSessionId", "integer" ]
											convert => [ "ThreadID", "integer" ]
											convert => [ "Version", "integer" ]
										}		
								}																			
						if [EventID] == 2 {
										mutate {
											split => ["Hashes", ","]
											convert => [ "ProcessID", "integer" ]														
											convert => [ "RecordNumber", "integer" ]
											convert => [ "SequenceNumber", "integer" ]
											convert => [ "SeverityValue", "integer" ]														
											convert => [ "ThreadID", "integer" ]
										}		
								}
						else if [EventID] == 3 {
						
							if [DestinationIp] == '$RemoveSomeUnwatedConnectionsSuchAsConnectionToLogstashServer' { #TODO:Specific
										drop { }
								}
							mutate {
										rename => [ 'DestinationIp', 'dst_ip' ]
										rename => [ 'DestinationPort', 'dst_port' ]
										rename => [ 'SourceIp', 'src_ip' ]
										rename => [ 'SourcePort', 'src_port' ]
										rename => [ 'Protocol', 'protocol']
										lowercase => [ 'DestinationHostname', 'SourceHostname' ]
										convert => [ "src_port", "integer" ]
										convert => [ "dst_port", "integer" ]
										convert => [ "ProcessID", "integer" ]													
										convert => [ "RecordNumber", "integer" ]													
										convert => [ "SequenceNumber", "integer" ]
										convert => [ "SeverityValue", "integer" ]													
										convert => [ "ThreadID", "integer" ]													
									}
							#if [DestinationIsIpv6] == "true" {
							#					geoip {
							#						source => "dst_ip"
							#						target => "dst_ip_geoip"
							#						database => "/usr/share/GeoIP/GeoLiteCityv6.dat"
							#						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
							#						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
							#						}
							#					geoip {
							#						source => "dst_ip"
							#						target => "dst_ip_geoip"
							#						database => "/usr/share/GeoIP/GeoIPASNumv6.dat"
							#						 }																	
							#				}
											
							if [DestinationIsIpv6] == "false" {
												geoip {
															source => "src_ip"
															target => "src_ip_geoip"
															database =>"/usr/share/GeoIP/GeoLiteCity.dat"
															add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
															add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
														}

												geoip {
														source => "dst_ip"
														target => "dst_ip_geoip"
														database =>"/usr/share/GeoIP/GeoIPASNum.dat"
														 }										
											}
							#if [SourceIsIpv6] == "true" {
							#					geoip {
							#						source => "src_ip"
							#						target => "src_ip_geoip"
							#						database => "/usr/share/GeoIP/GeoLiteCityv6.dat"
							#						add_field => [ "[src_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
							#						add_field => [ "[src_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
							#						}
							#					geoip {
							#						source => "src_ip"
							#						target => "src_ip_geoip"
							#						database => "/usr/share/GeoIP/GeoIPASNumv6.dat"
							#						 }																	
							#				}
											
							if [SourceIsIpv6] == "false" {
												geoip {
															source => "dst_ip"
															target => "dst_ip_geoip"
															database =>"/usr/share/GeoIP/GeoLiteCity.dat"
															add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
															add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
														}

												geoip {
														source => "src_ip"
														target => "src_ip_geoip"
														database =>"/usr/share/GeoIP/GeoIPASNum.dat"
														 }										
											}										
									}																														
						else if [EventID] == 5 {
										mutate {
											split => ["Hashes", ","]
											convert => [ "ProcessID", "integer" ]														
											convert => [ "RecordNumber", "integer" ]														
											convert => [ "SequenceNumber", "integer" ]														
											convert => [ "ThreadID", "integer" ]														
										}		
								}																			
						else if [EventID] == 6 {
										mutate {
											split => ["Hashes", ","]
										}		
								}																			
						else if [EventID] == 7 {
										mutate {
											split => ["Hashes", ","]
										}		
								}
						}
					else {
						
						if [EventID] == 0 or [EventID] == 104 or [EventID] == 1100 or [EventID] == 1102 or [EventID] == 2005 or [EventID] == 4624 or [EventID] == 4625 or [EventID] == 4634 or [EventID] == 4648 or [EventID] == 4698 or [EventID] == 4699 or [EventID] == 4700 or [EventID] == 4701 or [EventID] == 4702 or [EventID] == 4720  or [EventID] == 4722  or [EventID] == 4723  or [EventID] == 4724  or [EventID] == 4725  or [EventID] == 4726 or [EventID] == 4727 or [EventID] == 4728 or [EventID] == 4729 or [EventID] == 4730 or [EventID] == 4731 or [EventID] == 4732 or [EventID] == 4733 or [EventID] == 4734 or [EventID] == 4735 or [EventID] == 4737 or [EventID] == 4740 or [EventID] == 4742 or [EventID] == 4743 or [EventID] == 4744 or [EventID] == 4745 or [EventID] == 4746 or [EventID] == 4747 or [EventID] == 4748 or [EventID] == 4749 or [EventID] == 4750 or [EventID] == 4751 or [EventID] == 4752 or [EventID] == 4753 or [EventID] == 4754 or [EventID] == 4755 or [EventID] == 4756 or [EventID] == 4757 or [EventID] == 4758 or [EventID] == 4764 or [EventID] == 4768 or [EventID] == 4769 or [EventID] == 4770 or [EventID] == 4771 or [EventID] == 4772 or [EventID] == 4868 or [EventID] == 4869 or [EventID] == 4870 or [EventID] == 4871 or [EventID] == 4872 or [EventID] == 4873 or [EventID] == 4874 or [EventID] == 4875 or [EventID] == 4876 or [EventID] == 4877 or [EventID] == 4878 or [EventID] == 4879 or [EventID] == 4880 or [EventID] == 4881 or [EventID] == 4882 or [EventID] == 4883 or [EventID] == 4884 or [EventID] == 4885 or [EventID] == 4886 or [EventID] == 4887 or [EventID] == 4888 or [EventID] == 4889 or [EventID] == 4890 or [EventID] == 4891 or [EventID] == 4892 or [EventID] == 4893 or [EventID] == 4894 or [EventID] == 4895 or [EventID] == 4896 or [EventID] == 4897 or [EventID] == 4898 or [EventID] == 4738 or [EventID] == 4781 or [EventID] == 4767 {
									mutate {
												rename => [ "Message", "description" ]
												#remove_field => [  ]
												convert => [ "ProcessID", "integer" ]
												convert => [ "RecordNumber", "integer" ]
												convert => [ "ThreadID", "integer" ]
												lowercase => [ "Hostname" ]
											}

									translate {
												  field => "EventID"
												  destination => "event_description"
												  dictionary => [
																	"104", "event log was cleared",
																	"106", "dhcp was created",
																	"107", "dhcp was cleared",
																	"1100", "event log service stopped",
																	"1102", "audit log was cleared",
																	"2005", "a rule has been modified in the windows firewall exception list",
																	"4624", "an account was successfully logged on",
																	"4625", "an account failed to logon",
																	"4634", "an account was successfully logged off",
																	"4648", "a logon was attempted using explicit credentials",
																	"4698", "a scheduled task was created",
																	"4699", "a scheduled task was deleted",
																	"4700", "a scheduled task was enabled",
																	"4701", "a scheduled task was disabled",
																	"4702", "a scheduled task was updated",
																	"4720", "a user account was created",
																	"4722", "a user account was enabled",
																	"4723", "an attempt was made to change an account's password",
																	"4724", "an attempt was made to reset an account's password",
																	"4725", "a user account was disabled",
																	"4726", "a user account was deleted",
																	"4727", "a security-enabled global group was created",
																	"4728", "a member was added to a security-enabled global group",
																	"4729", "a member was removed from a security-enabled global group",
																	"4730", "a security-enabled global group was deleted",
																	"4731", "a security-enabled local group was created",
																	"4732", "a member was added to a security-enabled local group",
																	"4733", "a member was removed from a security-enabled local group",
																	"4734", "a security-enabled local group was deleted",
																	"4735", "a security-enabled local group was changed",
																	"4737", "a security-enabled global group was changed",
																	"4738", "a user account was changed",
																	"4781", "the name of an account was changed:",
																	"4767", "a user account was unlocked",
																	"4740", "a user account was locked out",
																	"4742", "a computer account was changed",
																	"4743", "a computer account was deleted",
																	"4744", "a security-disabled local group was created",
																	"4745", "a security-disabled local group was changed",
																	"4746", "a member was added to a security-disabled local group",
																	"4747", "a member was removed from a security-disabled local group",
																	"4748", "a security-disabled local group was deleted",
																	"4749", "a security-disabled global group was created",
																	"4750", "a security-disabled global group was changed",
																	"4751", "a member was added to a security-disabled global group",
																	"4752", "a member was removed from a security-disabled global group",
																	"4753", "a security-disabled global group was deleted",
																	"4754", "a security-enabled universal group was created",
																	"4755", "a security-enabled universal group was changed",
																	"4756", "a member was added to a security-enabled universal group",
																	"4757", "a member was removed from a security-enabled universal group",
																	"4758", "a security-enabled universal group was deleted",
																	"4764", "a group’s type was changed",
																	"4768", "a kerberos authentication ticket (tgt) was requested",
																	"4769", "a kerberos service ticket was requested",
																	"4770", "a kerberos service ticket was renewed",
																	"4771", "kerberos pre-authentication failed",
																	"4772", "a kerberos authentication ticket request failed",
																	"4868", "the certificate manager denied a pending certificate request",
																	"4869", "certificate services received a resubmitted certificate request",
																	"4870", "certificate services revoked a certificate",
																	"4871", "certificate services received a request to publish the certificate revocation list (crl)",
																	"4872", "certificate services published the certificate revocation list (crl)",
																	"4873", "a certificate request extension changed",
																	"4874", "one or more certificate request attributes changed",
																	"4875", "certificate services received a request to shut down",
																	"4876", "certificate services backup started",
																	"4877", "certificate services backup completed",
																	"4878", "certificate services restore started",
																	"4879", "certificate services restore completed",
																	"4880", "certificate services started",
																	"4881", "certificate services stopped",
																	"4882", "the security permissions for certificate services changed",
																	"4883", "certificate services retrieved an archived key",
																	"4884", "certificate services imported a certificate into its database",
																	"4885", "the audit filter for certificate services changed",
																	"4886", "certificate services received a certificate request",
																	"4887", "certificate services approved a certificate request and issued a certificate",
																	"4888", "certificate services denied a certificate request",
																	"4889", "certificate services set the status of a certificate request to pending",
																	"4890", "the certificate manager settings for certificate services changed",
																	"4891", "a configuration entry changed in certificate services",
																	"4892", "a property of certificate services changed",
																	"4893", "certificate services archived a key",
																	"4894", "certificate services imported and archived a key",
																	"4895", "certificate services published the ca certificate to active directory domain services",
																	"4896", "one or more rows have been deleted from the certificate database",
																	"4897", "role separation enabled:",
																	"4898", "certificate services loaded a template"
																]
												}
							}
					
						else {
									drop { }
							}
						}
				}

				####Juniper SSL VPN User Logs
				if [host] == "$SSLVPNLogServer" { #TODO:Specific

					if [facility_label] == "kernel" {

						grok     {

                                                   match => [ "message", "<142>\s+%{TIMESTAMP_ISO8601:ts2}\s+:\s+%{TIMESTAMP_ISO8601:ts}\s+\-\s+(?<device>(ive))\s+\-\s+\[%{IP:src_ip}\]\s*(?<ad_domain>(\w+))\\?%{USERNAME:username}\((?<user_realm>(\w+))\)\[(?<user_role>(\w+|w?))\]\s+\-\s+(?<event>(.*))" ]

						}

						geoip {
							source => "src_ip"
							target => "src_ip_geoip"
							database =>"/usr/share/GeoIP/GeoLiteCity.dat"
							add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
							add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
						}

						geoip {
							source => "src_ip"
							target => "src_ip_geoip"
							database =>"/usr/share/GeoIP/GeoIPASNum.dat"
						}

						mutate {
								remove_field => "tags"
								remove_field => "ts2"
								update => [ 'type', 'juniper_ssl_vpn_user_log' ]
								convert => [ "[src_ip_geoip][coordinates]", "float" ]
								convert => [ "[dst_ip_geoip][coordinates]", "float" ]
						}
					}



					else if [message] {

						grok     {

							match => [ "message", ".*" ]

						}

						mutate {
								update => [ 'type', 'juniper_ssl_vpn_user_log' ]
						}

					}

				}

				####Tipping Security Event Log
				if [host] == "$TippingPointIP" { #TODO:Specific
					#####Logs to Send:
					#${signatureUUID}	${eventTimestamp}	${arcSightFilterName}	${srcZone}	${destZone}	${profileName}	${flowControl}	${hitCount}	${categoryName}	${vlanTag}	${protocol}	${srcAddressv4}	${srcAddressv6}	${srcPort}	${protocol}	${destAddressv4}	${destAddressv6}	${destPort}	${uriString}	${uriMethod}	${uriHost}	${msgParameters}


					if [message] {

						csv {
							separator => "	"
							columns => [ "remove_me", "ts",  "signature_name",  "Inbound Interface",  "Outbound Interface",  "profile_name",  "Action",  "hit_count",  "category_name",  "vlan_number",  "protocol",  "srcAddressv4",  "srcAddressv6",  "src_port",  "protocol",  "destAddressv4",  "destAddressv6",  "dst_port",  "uri",  "method",  "http_host", "messsage_parameters" ]
                 		}

						if [srcAddressv6] == "null" {

							mutate {
									add_field => [ "src_ip", "%{srcAddressv4}" ]
									}

							geoip {
								source => "src_ip"
								target => "src_ip_geoip"
								database => "/usr/share/GeoIP/GeoLiteCity.dat"
								add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
								add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
								}

							geoip {
								source => "src_ip"
								target => "src_ip_geoip"
								database =>"/usr/share/GeoIP/GeoIPASNum.dat"
								 }

						}

						else if [srcAddressv6] != "null" {

							mutate {
									add_field => [ "src_ip", "%{srcAddressv6}" ]
									}

							geoip {
								source => "src_ip"
								target => "src_ip_geoip"
								database => "/usr/share/GeoIP/GeoLiteCity.dat"
								add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
								add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
								}

							geoip {
								source => "src_ip"
								target => "src_ip_geoip"
								database =>"/usr/share/GeoIP/GeoIPASNum.dat"
								 }


						}

						if [destAddressv6] == "null" {

							mutate {
									add_field => [ "dst_ip", "%{destAddressv4}" ]
									}

							geoip {
								source => "dst_ip"
								target => "dst_ip_geoip"
								database =>"/usr/share/GeoIP/GeoLiteCity.dat"
								add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
								add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
								}
							geoip {
								source => "dst_ip"
								target => "dst_ip_geoip"
								database =>"/usr/share/GeoIP/GeoIPASNum.dat"
								 }

						}

						else if [destAddressv6] == "null" {

							mutate {
									add_field => [ "dst_ip", "%{destAddressv6}" ]
									}

							geoip {
								source => "dst_ip"
								target => "dst_ip_geoip"
								database =>"/usr/share/GeoIP/GeoLiteCity.dat"
								add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
								add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
								}
							geoip {
								source => "dst_ip"
								target => "dst_ip_geoip"
								database =>"/usr/share/GeoIP/GeoIPASNum.dat"
								 }

						}

						mutate {
								convert => [ "src_port", "integer" ]
								convert => [ "dst_port", "integer" ]
								convert => [ "hit_count", "integer" ]
								convert => [ "vlan_number", "integer" ]
								remove_field => [ "tags", "remove_me", "srcAddressv4", "srcAddressv6", "destAddressv4", "destAddressv6" ]
								update => [ 'type', 'tippingpoint_log' ]
								convert => [ "[src_ip_geoip][coordinates]", "float" ]
								convert => [ "[dst_ip_geoip][coordinates]", "float" ]
								lowercase => [ 'protocol' ]
							}
					}
				}

			####Suricata IDS Log
			if [type] == "suricata_log" {

				#if [event_type] == "fileinfo" {

				#		mutate {
				#			convert => [ 'fileinfo.size', "integer" ]
				#			}

				#	}

				json {
						source => "message"
					}

				if [event_type] == "alert" {

						mutate {
							convert => [ 'alert.signature_id', "integer" ]
							}

					}

				mutate {
						remove_field => [ "host" ]
						rename => [ 'dest_ip', 'dst_ip' ]
						rename => [ 'dest_port', 'dst_port' ]
						rename => [ 'proto', 'protocol' ]
						rename => [ 'vlan', 'vlan_number' ]
						convert => [ "src_port", "integer" ]
						convert => [ "dst_port", "integer" ]
						lowercase => [ "protocol" ]
					}

				geoip {
						source => "src_ip"
						target => "src_ip_geoip"
						database =>"/usr/share/GeoIP/GeoLiteCity.dat"
						add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][longitude]}" ]
						add_field => [ "[src_ip_geoip][coordinates]", "%{[src_ip_geoip][latitude]}"  ]
						}

				geoip {
					source => "src_ip"
					target => "src_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
					 }

				geoip {
						source => "dst_ip"
						target => "dst_ip_geoip"
						database =>"/usr/share/GeoIP/GeoLiteCity.dat"
						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][longitude]}" ]
						add_field => [ "[dst_ip_geoip][coordinates]", "%{[dst_ip_geoip][latitude]}"  ]
						 }
				geoip {
					source => "dst_ip"
					target => "dst_ip_geoip"
					database =>"/usr/share/GeoIP/GeoIPASNum.dat"
					 }

				mutate {
						convert => [ "[src_ip_geoip][coordinates]", "float" ]
						convert => [ "[dst_ip_geoip][coordinates]", "float" ]
					}
				}


			####FireEye Logs
			if [type] == "fireeye_log" {

				grok {

						match => [ "message", "" ]
				}
			}

			####Logs failed to parse
			if "_dateparsefailure" in [tags] {
						drop { }
				}

			if [message] == "Failed parsing date from field" {
					drop { }
					}


		}
	}
}

output {

        elasticsearch {
			cluster => "$ClusterName"
			host => "$HostIP"
			protocol => "http"
		}

}
